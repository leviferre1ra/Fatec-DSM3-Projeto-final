{% extends "allauth/layouts/base.html" %}

{% block content %}

<div class="m-0 font-[Inter] font-bold grid grid-cols-1 md:grid-cols-[450px_1fr] bg-white box-border">

  <!-- Painel lateral esquerdo -->
  <aside class="bg-white flex flex-col p-[30px] overflow-y-scroll max-h-screen py-9 scrollbar shadow-[10px_0px_6px_rgba(0,0,0,0.15)] z-[2]">

    <!-- Perfil -->
    <div class="flex items-center gap-[10px] hidden md:block">
      <span class="font-medium text-black text-[1.5rem] ml-3">Olá, <strong>{{ user.first_name|default:user.username }}</strong></span>
    </div>

    <!-- Modal de seleção de bairro -->
    <div id="div-dropdown-bairros"  class="bg-white mt-10 rounded-lg max-w-md text-center">
        <select id="dropdown-bairros" class="w-full p-3 mb-10 border border-gray-300 rounded-lg md:text-lg focus:ring-[#7083D9] focus:border-[#7083D9]">
            <option value="" disabled selected>Escolha um bairro...</option>
            <option value="todos">Todos</option>
            <option value="Anhanguera">Anhanguera</option>
            <option value="Antartica">Antártica</option>
            <option value="Aviacao">Aviação</option>
            <option value="Boqueirao">Boqueirão</option>
            <option value="Caicara">Caiçara</option>
            <option value="Canto do Forte">Canto do Forte</option>
            <option value="Cidade da Crianca">Cidade da Criança</option>
            <option value="Esmeralda">Esmeralda</option>
            <option value="Florida">Flórida</option>
            <option value="Gloria">Glória</option>
            <option value="Guilhermina">Guilhermina</option>
            <option value="Maracana">Maracanã</option>
            <option value="Melvi">Melvi</option>
            <option value="Mirim">Mirim</option>
            <option value="Nova Mirim">Nova Mirim</option>
            <option value="Ocian">Ocian</option>
            <option value="Princesa">Princesa</option>
            <option value="Quietude">Quietude</option>
            <option value="real">Real</option>
            <option value="Ribeiropolis">Ribeirópolis</option>
            <option value="Samambaia">Samambaia</option>
            <option value="Santa Marina">Santa Marina</option>
            <option value="Sitio do Campo">Sítio do Campo</option>
            <option value="Solemar">Solemar</option>
            <option value="Tupi">Tupi</option>
            <option value="Tupiry">Tupiry</option>
            <option value="vila sonia">Vila Sônia</option>
        </select>
    </div>


    <!-- Contagem regressiva -->
    <div class="text-center mb-[18px]">
      <h2 class="m-0 text-black font-semibold text-[1.5rem]">A coleta começa em:</h2>
      <h1 id="countdown" class="text-[4rem] text-[#7083D9] font-bold m-0">00:00:00</h1>
    </div>

    <!-- Próxima coleta -->
    <div class="bg-[#7083D9] text-white rounded-[10px] p-4 text-center mb-[23px] shadow-[10px_10px_5px_rgba(0,0,0,0.15)] z-[3]">
      <p class="m-[5px_3px] text-[1.3rem] font-normal"><strong>Próxima Coleta:</strong> <span id="proxima-coleta-date">--/--/----</span></p>
      <p class="m-[5px_3px] text-[1.3rem] font-normal"><strong>Horário Previsto:</strong> <span id="horario-previsto">--:--</span></p>
    </div>

    <!-- Alerta -->
    <div id="create-alert-container" class="text-center mb-[25px] hidden">
      <h2 class="m-0 text-black font-semibold text-[1.5rem]">Perdeu o horário da coleta?</h2>
      <a href="#" id="create-alert-link" class="text-[#7083D9] no-underline font-semibold text-[1.2rem] hover:underline">Crie um alerta para lembrar</a>
    </div>

    <!-- ALERT Modal -->
    <div id="alert-overlay" class="fixed inset-0 bg-black/50 hidden z-70"></div>
    <div id="alert-modal" class="fixed inset-0 flex items-center justify-center hidden z-70 p-4">
      <div class="bg-white rounded-lg w-full max-w-md p-5 shadow-lg">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-semibold">Criar alerta</h3>
          <button id="alert-close" class="text-gray-500 hover:text-gray-800">✕</button>
        </div>

        <form id="alert-form" class="text-sm">
          <div>
            <label class="block font-medium mb-3">Data</label>
            <input id="alert-date" type="date" class="w-full p-2 border rounded" />
          </div>
          <div>
            <label class="block font-medium mb-3 mt-5">Hora</label>
            <input id="alert-time" type="time" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="block font-medium mb-3 mt-5">Dias da semana (marque para repetir semanalmente)</label>
            <div class="grid grid-cols-4 gap-2 text-xs">
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="0" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Dom</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="1" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Seg</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="2" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Ter</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="3" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Qua</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="4" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Qui</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="5" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Sex</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" value="6" class="day-checkbox h-4 w-4 rounded border border-gray-300 accent-[#7083D9] checked:bg-[#7083D9] checked:border-[#7083D9] focus:ring-2 focus:ring-[#7083D9]/30" />
                <span>Sáb</span>
              </label>
            </div>
          </div>

          <div class="flex justify-end items-center gap-3 mt-2 ">
            <button type="button" id="alert-cancel" class="px-3 py-2 rounded border">Cancelar</button>
            <button type="submit" id="alert-save" class="px-3 py-2 rounded bg-[#7083D9] text-white">Salvar alerta</button>
          </div>

          <p id="alert-status" class="text-sm text-center hidden"></p>
        </form>

        <hr class="my-3" />
        <div>
          <h4 class="font-semibold text-sm mb-2">Alertas salvos</h4>
          <ul id="alerts-list" class="text-sm space-y-2"></ul>
        </div>
      </div>
    </div>

  <!-- Últimas coletas -->
  <div class="w-full mb-[25px] flex justify-center hidden md:block">
    <div class="bg-[#ffb84d] text-[#4e4e4e] text-[1rem] rounded-[10px] p-[14px]
      shadow-[10px_10px_5px_rgba(0,0,0,0.15)] z-[3] text-center
      mx-auto w-full">

      <h3 class="text-black m-0 mb-[8px] text-[1.1rem]">Últimas coletas</h3>

      <ul id="ultimas-coletas-list" class="list-none m-0 px-[6px] text-[#4e4e4e]">
        <!-- preenchido dinamicamente -->
      </ul>
    </div>
  </div>


      <!-- Rodapé -->
    <footer class="text-center text-[0.9rem] font-semibold text-[#4e4e4e] mt-6 hidden md:block">
      Precisa de ajuda? <a href="#ajuda" class="text-[#7083D9] no-underline hover:underline">Clique aqui</a>
    </footer>
  </aside>

  
  <!-- Mapa -->
  <main class="w-full h-full z-[1]">
    <div id="map" class="w-full h-screen"></div>
  </main>

</div>

<!-- Leaflet CSS e JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  let map;
  let geoJsonLayer;
  let bairroSelecionado = localStorage.getItem('bairroSelecionado') || '';
  let initialGeojson = null;
  let currentNextDate = null;
  let countdownInterval = null;
  // Dia atual (passado do backend)
  const diaAtual = "{{ dia_atual|escapejs }}";

  // Mapeamento português -> número do getDay() (0 = domingo)
  const diaParaNumero = {
    'domingo': 0,
    'segunda': 1,
    'terca': 2, 'terça': 2,
    'quarta': 3,
    'quinta': 4,
    'sexta': 5,
    'sabado': 6, 'sábado': 6
  };

  function parseHorario(horarioStr) {
    if (!horarioStr) return { h: 0, m: 0 };
    const parts = horarioStr.trim().split(':');
    const h = parseInt(parts[0], 10) || 0;
    const m = parseInt(parts[1], 10) || 0;
    return { h, m };
  }

  function getNextDateForFeature(feature) {
    const props = feature.properties || {};
    const dias = Array.isArray(props.Dias) ? props.Dias.map(d => d.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '')) : [];
    const horario = props['Horário'] || props['Horario'] || props.horario || '';
    const { h, m } = parseHorario(horario);

    const now = new Date();
    for (let offset = 0; offset < 14; offset++) { // checar próximas duas semanas para segurança
      const candidate = new Date(now);
      candidate.setDate(now.getDate() + offset);
      candidate.setHours(h, m, 0, 0);
      const candidateDayNum = candidate.getDay(); // 0..6
      // verificar se candidateDayNum está em dias
      const matches = dias.some(d => diaParaNumero[d] === candidateDayNum);
      if (matches) {
        // Se for hoje (offset==0), garantir que o horário ainda não passou
        if (offset === 0 && candidate <= now) {
          continue;
        }
        return candidate;
      }
    }
    return null;
  }

  function formatDateBR(date) {
    if (!date) return '--/--/----';
    const dd = String(date.getDate()).padStart(2, '0');
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const yyyy = date.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  }

  function formatTime(date) {
    if (!date) return '--:--';
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
  }

  function startCountdown(toDate) {
    currentNextDate = toDate;
    if (countdownInterval) clearInterval(countdownInterval);
    if (!toDate) {
      document.getElementById('countdown').textContent = '—';
      return;
    }
    function update() {
      const now = new Date();
      let diff = Math.max(0, Math.floor((toDate - now) / 1000)); // segundos
      const days = Math.floor(diff / 86400);
      diff %= 86400;
      const hours = Math.floor(diff / 3600);
      diff %= 3600;
      const minutes = Math.floor(diff / 60);
      const seconds = diff % 60;
      let text = '';
      if (days > 0) text += days + 'd ';
      text += String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
      document.getElementById('countdown').textContent = text;
      if (toDate - now <= 0) {
        clearInterval(countdownInterval);
        // opcional: recarregar dados do bairro para próxima ocorrência
      }
    }
    update();
    countdownInterval = setInterval(update, 1000);
  }

  // Inicializar mapa
  function inicializarMapa() {
    map = L.map('map').setView([-24.0053, -46.4124], 15);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    geoJsonLayer = L.geoJSON(null, {
      style: function(feature) {
        const props = feature.properties || {};
        const dias = Array.isArray(props.Dias) ? props.Dias : [];
        const normalized = dias.map(d => d.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''));
        const isActive = normalized.includes(diaAtual.toString().toLowerCase());
        return {
          color: isActive ? '#7083D9' : '#A6A6A6',
          weight: 2,
          opacity: 0.8,
          fillOpacity: 0.3,
          fillColor: isActive ? '#7083D9' : '#A6A6A6'
        };
      },
      onEachFeature: function(feature, layer) {
        const props = feature.properties || {};
        const diasArray = Array.isArray(props.Dias) ? props.Dias : [];
        const dias = diasArray.join(', ');
        const popupContent = `
          <div class="popup-content">
            <b>${props.Bairro}</b><br>
            <strong>Dias:</strong> ${dias}<br>
            <strong>Período:</strong> ${props.Período}<br>
            <strong>Horário:</strong> ${props.Horário}
          </div>
        `;
        layer.bindPopup(popupContent);
      }
    }).addTo(map);
  }

  // Centralizar no bounds das features
  function centralizarNoMapa(geojsonData) {
    if (!geojsonData || !geojsonData.features || geojsonData.features.length === 0) {
      return;
    }
    const bounds = L.geoJSON(geojsonData).getBounds();
    map.fitBounds(bounds, { padding: [50, 50] });
  }

  // Carregar GeoJSON na camada e centralizar
  function carregarGeojson(geojsonData) {
    if (geoJsonLayer) {
      geoJsonLayer.clearLayers();
      geoJsonLayer.addData(geojsonData);
    }
    centralizarNoMapa(geojsonData);
  }

  // ----------------- Últimas coletas (últimas 4 ocorrências) -----------------
  function normalizeDia(d) {
    return (d || '').toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }

  // calcula as últimas `count` datas em que a coleta ocorreu para um array de features
  function calcularUltimasColetas(features, count = 4) {
    const now = new Date();
    const ocorrencias = [];

    if (!features || features.length === 0) return [];

    // para cada feature, para cada dia em que passa, calcular a última ocorrência (e algumas anteriores)
    features.forEach(f => {
      const p = f.properties || {};
      const dias = Array.isArray(p.Dias) ? p.Dias.map(normalizeDia) : [];
      if (dias.length === 0) return;
      const horario = p['Horário'] || p['Horario'] || p.horario || '00:00';
      const parts = horario.split(':');
      const h = parseInt(parts[0], 10) || 0;
      const m = parseInt(parts[1], 10) || 0;

      dias.forEach(diaStr => {
        const norm = normalizeDia(diaStr);
        const target = diaParaNumero[norm];
        if (target === undefined) return;

        // construir datetime de hoje com a hora da coleta
        const cand = new Date(now);
        cand.setHours(h, m, 0, 0);
        const todayWD = cand.getDay();

        // delta dias entre hoje e o weekday alvo (0..6)
        let delta = (todayWD - target + 7) % 7;
        // se hoje é o dia alvo, mas horário ainda não passou -> última ocorrência foi 7 dias atrás
        if (delta === 0 && cand > now) delta = 7;

        const last = new Date(cand);
        last.setDate(cand.getDate() - delta);

        // adicionar last e mais 3 ocorrências anteriores (subtraindo semanas)
        for (let i = 0; i < 4; i++) {
          const dt = new Date(last);
          dt.setDate(last.getDate() - 7 * i);
          if (dt <= now) {
            ocorrencias.push({ date: dt, horario: `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}` });
          }
        }
      });
    });

    // ordenar desc e pegar os 4 mais recentes, removendo duplicatas
    ocorrencias.sort((a, b) => b.date - a.date);
    const unique = [];
    const seen = new Set();
    for (const o of ocorrencias) {
      const key = o.date.toISOString();
      if (!seen.has(key)) {
        unique.push(o);
        seen.add(key);
      }
      if (unique.length >= count) break;
    }
    return unique;
  }

  function atualizarUltimasColetasUI(features) {
    const ul = document.getElementById('ultimas-coletas-list');
    if (!ul) return;
    ul.innerHTML = '';
    const ultimas = calcularUltimasColetas(features, 4);
    if (!ultimas.length) {
      const li = document.createElement('li');
      li.className = 'py-[4px] font-medium border-b border-dashed border-[rgba(0,0,0,0.06)]';
      li.textContent = 'Nenhuma coleta registrada ainda';
      ul.appendChild(li);
      return;
    }
    ultimas.forEach(item => {
      const li = document.createElement('li');
      li.className = 'py-[4px] font-medium border-b border-dashed border-[rgba(0,0,0,0.06)] flex items-center justify-center gap-3';
      li.innerHTML = `<span>${formatDateBR(item.date)}</span><span class="text-sm text-[#4e4e4e]">${item.horario}</span>`;
      ul.appendChild(li);
    });
  }
  // ----------------- fim Últimas coletas -----------------

  // calcula próxima coleta entre features e atualiza UI
  function atualizarInfoDasFeatures(geojsonData) {
    if (!geojsonData || !geojsonData.features || geojsonData.features.length === 0) {
      document.getElementById('proxima-coleta-date').textContent = '--/--/----';
      document.getElementById('horario-previsto').textContent = '--:--';
      startCountdown(null);
      atualizarUltimasColetasUI([]);
      return;
    }
    // para cada feature calcula a próxima data; escolhe a mais próxima (menor)
    let next = null;
    let nextFeature = null;
    geojsonData.features.forEach(f => {
      const d = getNextDateForFeature(f);
      if (d && (!next || d < next)) {
        next = d;
        nextFeature = f;
      }
    });

    // atualizar lista de últimas coletas imediatamente
    atualizarUltimasColetasUI(geojsonData.features);

    if (next) {
      document.getElementById('proxima-coleta-date').textContent = formatDateBR(next);
      document.getElementById('horario-previsto').textContent = formatTime(next);
      startCountdown(next);
    } else {
      document.getElementById('proxima-coleta-date').textContent = 'Sem previsão';
      document.getElementById('horario-previsto').textContent = '--:--';
      startCountdown(null);
    }
  }

  function updateCreateAlertVisibility(bairro){
    try{
      const c = document.getElementById('create-alert-container');
      if (!c) return;
      if (bairro && bairro !== 'todos') c.classList.remove('hidden');
      else c.classList.add('hidden');
    }catch(e){}
  }

  // Persist alert modal prefill across reloads
  function saveAlertPrefill(prefill){
    try{ localStorage.setItem('deolho_alert_prefill', JSON.stringify(prefill || null)); }catch(e){}
  }
  function loadAlertPrefill(){
    try{ const s = localStorage.getItem('deolho_alert_prefill'); return s ? JSON.parse(s) : null; }catch(e){ return null; }
  }

  document.getElementById('dropdown-bairros').addEventListener('change', function() {
    const bairro = this.value;

    // atualizar visibilidade do link de criar alerta ("todos" não conta como um bairro)
    updateCreateAlertVisibility(bairro);

    if (!bairro) return;

    // Caso especial: mostrar todos os bairros (restaurar visão completa)
    if (bairro === 'todos') {
      localStorage.removeItem('bairroSelecionado');
      try{ saveAlertPrefill(null); }catch(e){}
      if (initialGeojson) {
        carregarGeojson(initialGeojson);
        atualizarInfoDasFeatures(initialGeojson);
      }
      return;
    }

    // Salvar bairro selecionado no localStorage
    localStorage.setItem('bairroSelecionado', bairro);

    // Fazer requisição AJAX ao endpoint que já implementaste
    fetch(`/api/carregar-bairro/?bairro=${encodeURIComponent(bairro)}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // data.geojson já é um FeatureCollection
          carregarGeojson(data.geojson);
          atualizarInfoDasFeatures(data.geojson);
          // garantir que a lista de últimas coletas também foi atualizada
          atualizarUltimasColetasUI(data.geojson.features || []);

          // Pré-preencher e abrir modal de alerta com próxima coleta do bairro carregado
          try{
            const features = data.geojson && data.geojson.features ? data.geojson.features : [];
            let next = null; let nextFeature = null;
            features.forEach(f => {
              try{ const d = getNextDateForFeature(f); if (d && (!next || d < next)){ next = d; nextFeature = f; } }catch(e){}
            });
            if (next){
              // preencher date (yyyy-mm-dd) e time (HH:MM)
              const yyyy = next.getFullYear();
              const mm = String(next.getMonth()+1).padStart(2,'0');
              const dd = String(next.getDate()).padStart(2,'0');
              const hh = String(next.getHours()).padStart(2,'0');
              const mins = String(next.getMinutes()).padStart(2,'0');
              const dateInput = document.getElementById('alert-date');
              const timeInput = document.getElementById('alert-time');
              if (dateInput) dateInput.value = `${yyyy}-${mm}-${dd}`;
              if (timeInput) timeInput.value = `${hh}:${mins}`;

              // marcar checkboxes de dias com base em nextFeature.properties.Dias (ou marcar o dia da semana da próxima ocorrência)
              const dayCheckboxes = document.querySelectorAll('.day-checkbox');
              dayCheckboxes.forEach(cb=>cb.checked = false);
              const dias = (nextFeature && nextFeature.properties && nextFeature.properties.Dias) ? nextFeature.properties.Dias : [];
              if (dias && dias.length){
                dias.forEach(dia => {
                  try{
                    const key = dia.toString().toLowerCase().normalize('NFD').replace(/[^\w\s]|[\u0300-\u036f]/g,'').replace(/[\u0300-\u036f]/g,'');
                    // mapping available in diaParaNumero
                    const idx = diaParaNumero[key];
                    if (idx !== undefined){
                      const cb = document.querySelector('.day-checkbox[value="'+idx+'"]'); if (cb) cb.checked = true;
                    }
                  }catch(e){}
                });
              } else {
                const cb = document.querySelector('.day-checkbox[value="'+next.getDay()+'"]'); if (cb) cb.checked = true;
              }
              // persistir prefill para restaurar após reload
              try{
                const diasArr = (nextFeature && nextFeature.properties && nextFeature.properties.Dias) ? nextFeature.properties.Dias : [];
                const prefillDays = [];
                if (diasArr && diasArr.length){
                  diasArr.forEach(dia => {
                    try{
                      const normalized = dia.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
                      const key = normalized.replace(/[^\w\s]/g,'');
                      const idx = diaParaNumero[key];
                      if (idx !== undefined && idx !== null) prefillDays.push(idx);
                    }catch(e){}
                  });
                }
                if (!prefillDays.length) prefillDays.push(next.getDay());
                saveAlertPrefill({ date: `${yyyy}-${mm}-${dd}`, time: `${hh}:${mins}`, days: Array.from(new Set(prefillDays)) });
              }catch(e){}
            }
          }catch(e){ console.warn('Não foi possível pré-preencher modal:', e); }
        } else {
          console.error('Erro ao carregar bairro:', data.error);
        }
      })
      .catch(error => console.error('Erro:', error));
  });

  // Inicializar na primeira carga
  document.addEventListener('DOMContentLoaded', function() {
    inicializarMapa();

    initialGeojson = {{ geojson|default:"null"|safe }};
    if (initialGeojson) {
      carregarGeojson(initialGeojson);
      atualizarInfoDasFeatures(initialGeojson);
    } else {
      atualizarUltimasColetasUI([]);
    }

    // Restaurar bairro selecionado do localStorage
    const dropdown = document.getElementById('dropdown-bairros');
    if (bairroSelecionado) {
      dropdown.value = bairroSelecionado;
      if (bairroSelecionado !== 'todos') {
        // requisitar os dados filtrados sem recarregar a página
        fetch(`/api/carregar-bairro/?bairro=${encodeURIComponent(bairroSelecionado)}`)
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              carregarGeojson(data.geojson);
              atualizarInfoDasFeatures(data.geojson);
            }
          })
          .catch(err => console.error(err));
      }
    } else {
      dropdown.value = 'todos';
    }
    // atualizar visibilidade do link de criar alerta conforme seleção restaurada
    try{ updateCreateAlertVisibility(dropdown.value); }catch(e){}
  });

  (function(){
    const openBtn = document.getElementById('create-alert-link');
    const overlay = document.getElementById('alert-overlay');
    const modal = document.getElementById('alert-modal');
    const closeBtn = document.getElementById('alert-close');
    const cancelBtn = document.getElementById('alert-cancel');
    const form = document.getElementById('alert-form');
    const status = document.getElementById('alert-status');
    const alertsList = document.getElementById('alerts-list');
    // guarda dados pré-carregados ao selecionar bairro (não abre modal automaticamente)
    let alertPrefill = null;
    try{ alertPrefill = loadAlertPrefill(); }catch(e){ alertPrefill = null; }

    function openModal(){ 
      // fecha menu lateral se estiver aberto e desabilita botão hambúrguer enquanto modal de alerta estiver aberto
      const menuEl = document.getElementById('menu');
      const menuOverlay = document.getElementById('menu-overlay');
      const menuBtn = document.getElementById('menu-btn');
      if (menuEl && !menuEl.classList.contains('translate-x-full')) {
        menuEl.classList.add('translate-x-full');
      }
      if (menuOverlay) {
        menuOverlay.classList.add('hidden');
        menuOverlay.classList.add('opacity-0');
      }
      if (menuBtn) {
        // esconder totalmente o botão hambúrguer enquanto o modal de alerta estiver aberto
        menuBtn.classList.add('hidden');
        menuBtn.setAttribute('aria-hidden', 'true');
      }

        // preencher com dados pré-carregados (se houver)
        try{
          if (alertPrefill){
            const dateInput = document.getElementById('alert-date');
            const timeInput = document.getElementById('alert-time');
            if (dateInput && alertPrefill.date) dateInput.value = alertPrefill.date;
            if (timeInput && alertPrefill.time) timeInput.value = alertPrefill.time;
            const dayCheckboxes = document.querySelectorAll('.day-checkbox');
            dayCheckboxes.forEach(cb => cb.checked = false);
            if (Array.isArray(alertPrefill.days)){
              alertPrefill.days.forEach(i => {
                try{ const cb = document.querySelector('.day-checkbox[value="'+i+'"]'); if (cb) cb.checked = true; }catch(e){}
              });
            }
          }
        }catch(e){console.warn('Erro ao aplicar prefill no modal', e)}
        overlay.classList.remove('hidden');
        modal.classList.remove('hidden');
        renderAlertsList();
    }

    // Expose a small global helper so other scripts can prefill and open alert modal
    // Usage: window.openAlertModalWith({ date: 'yyyy-mm-dd', time: 'HH:MM', days: [0,1] })
    window.openAlertModalWith = function(prefill){
      try{
        alertPrefill = prefill || null;
        // persist global prefill so it survives reloads
        try{ saveAlertPrefill(alertPrefill); }catch(e){}
        // openModal will apply alertPrefill when present
          if (next){
            try{
              const yyyy = next.getFullYear();
              const mm = String(next.getMonth()+1).padStart(2,'0');
              const dd = String(next.getDate()).padStart(2,'0');
              const hh = String(next.getHours()).padStart(2,'0');
              const mins = String(next.getMinutes()).padStart(2,'0');
              const dateStr = `${yyyy}-${mm}-${dd}`;
              const timeStr = `${hh}:${mins}`;

              const dias = (nextFeature && nextFeature.properties && nextFeature.properties.Dias) ? nextFeature.properties.Dias : [];
              const prefillDays = [];
              if (dias && dias.length){
                dias.forEach(dia => {
                  try{
                    const normalized = dia.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
                    const key = normalized.replace(/[^\w\s]/g,'');
                    const idx = diaParaNumero[key];
                    if (idx !== undefined && idx !== null) prefillDays.push(idx);
                  }catch(e){}
                });
              }
              if (!prefillDays.length) prefillDays.push(next.getDay());

              if (window.openAlertModalWith){
                window.openAlertModalWith({ date: dateStr, time: timeStr, days: Array.from(new Set(prefillDays)) });
              } else {
                const dateInput = document.getElementById('alert-date');
                const timeInput = document.getElementById('alert-time');
                if (dateInput) dateInput.value = dateStr;
                if (timeInput) timeInput.value = timeStr;
                const dayCheckboxes = document.querySelectorAll('.day-checkbox');
                dayCheckboxes.forEach(cb=>cb.checked = false);
                (Array.isArray(prefillDays)?prefillDays:[prefillDays]).forEach(i=>{ const cb = document.querySelector('.day-checkbox[value="'+i+'"]'); if (cb) cb.checked = true; });
                const openBtn = document.getElementById('create-alert-link'); if (openBtn) openBtn.click();
              }
            }catch(e){ console.warn('Não foi possível pré-preencher modal:', e); }
          }
      }catch(e){ console.warn('openAlertModalWith failed', e); }
    };
    // Local storage helpers for alerts
    function loadAlerts(){
      try{
        const s = localStorage.getItem('deolho_alerts');
        return s ? JSON.parse(s) : [];
      }catch(e){ return []; }
    }

    function saveAlerts(arr){
      try{ localStorage.setItem('deolho_alerts', JSON.stringify(arr || [])); }catch(e){}
    }

    // Close the alert modal and restore UI state
    function closeModal(){
      try{
        overlay.classList.add('hidden');
        modal.classList.add('hidden');
        if (status) status.classList.add('hidden');
        const menuBtn = document.getElementById('menu-btn');
        if (menuBtn){ menuBtn.classList.remove('hidden'); menuBtn.removeAttribute('aria-hidden'); }
      }catch(e){ console.warn('closeModal failed', e); }
    }
    // Cookie helper (used to retrieve CSRF token)
    function getCookie(name){
      try{
        const matches = document.cookie.match(new RegExp('(^|; )' + name.replace(/([.*+?^${}()|[\]\\])/g,'\\$1') + '=([^;]*)'));
        return matches ? decodeURIComponent(matches[2]) : null;
      }catch(e){ return null; }
    }
    function renderAlertsList(){
      const arr = loadAlerts();
      alertsList.innerHTML = '';
      if (!arr.length) { alertsList.innerHTML = '<li class="text-xs text-gray-500">Nenhum alerta</li>'; return; }
      arr.forEach(a=>{
        const li = document.createElement('li');
        li.className = 'flex justify-between items-center';
        const txt = document.createElement('div');
        const days = (a.days && a.days.length)? a.days.map(d=>['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'][d]).join(', '): (a.date||'único');
        txt.innerHTML = `<div class="font-medium">${a.time} ${a.date?('— '+a.date):''}</div><div class="text-xs text-gray-600">${days}</div>`;
        const del = document.createElement('button');
        del.className = 'px-2 py-1 text-xs border rounded';
        del.textContent = 'Excluir';
        del.addEventListener('click', ()=>{
          const newArr = loadAlerts().filter(x=>x.id !== a.id);
          saveAlerts(newArr);
          renderAlertsList();
          scheduleAllAlerts(); // atualizar timers
        });
        li.appendChild(txt);
        li.appendChild(del);
        alertsList.appendChild(li);
      });
    }

    function uid(){ return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }

    // calcula próximo Date object para alerta (considera date OR days-of-week + time)
    function nextOccurrence(a){
      const now = new Date();
      const [hh,mm] = a.time.split(':').map(n=>parseInt(n,10)||0);
      if (a.date){ // specific date
        const parts = a.date.split('-'); // yyyy-mm-dd
        const dt = new Date(parts[0], parts[1]-1, parts[2], hh, mm, 0, 0);
        if (dt > now) return dt;
            if (next){
              // preparar prefill (não abrir automaticamente)
              const yyyy = next.getFullYear();
              const mm = String(next.getMonth()+1).padStart(2,'0');
              const dd = String(next.getDate()).padStart(2,'0');
              const hh = String(next.getHours()).padStart(2,'0');
              const mins = String(next.getMinutes()).padStart(2,'0');
              const dateStr = `${yyyy}-${mm}-${dd}`;
              const timeStr = `${hh}:${mins}`;

              // coletar índices dos dias (0=Dom .. 6=Sáb) a partir de nextFeature.properties.Dias se disponível
              const dias = (nextFeature && nextFeature.properties && nextFeature.properties.Dias) ? nextFeature.properties.Dias : [];
              const prefillDays = [];
              if (dias && dias.length){
                dias.forEach(dia => {
                  try{
                    const normalized = dia.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
                    const key = normalized.replace(/[^\w\s]/g,'');
                    const k = key;
                    const idx = diaParaNumero[k] !== undefined ? diaParaNumero[k] : null;
                    if (idx !== null && idx !== undefined) prefillDays.push(idx);
                  }catch(e){}
                });
              }
              
              // se não obteve dias, usar dia da semana da próxima ocorrência
              if (!prefillDays.length) prefillDays.push(next.getDay());

              alertPrefill = { date: dateStr, time: timeStr, days: Array.from(new Set(prefillDays)) };
            }
        const text = `Alerta: ${a.time}${a.date?(' • '+a.date):''}`;
        if (window.Notification && Notification.permission === 'granted'){
          new Notification('Alerta De Olho no Lixo', { body: text });
        } else {
          try { if (typeof navigator !== 'undefined' && navigator.vibrate) navigator.vibrate(200); } catch(e) {}
          alert(text);
        }
        // se é para dias da semana, agendar próxima ocorrência recursiva
        if (a.days && a.days.length){
          // agendar próxima chamada (re-run schedule)
          scheduleAlert(a);
        }
      }
      // note: original implementation above was corrupted; scheduling handled below
    }

    // ----- scheduling helpers -----
    let scheduled = {};

    function clearScheduled(){
      try{
        Object.keys(scheduled).forEach(id => {
          const o = scheduled[id];
          if (o.timeout) clearTimeout(o.timeout);
          if (o.interval) clearInterval(o.interval);
        });
      }catch(e){}
      scheduled = {};
    }

    function computeNextForAlert(a){
      const now = new Date();
      const [hh, mm] = (a.time || '00:00').split(':').map(n=>parseInt(n,10)||0);
      if (a.date){
        const parts = a.date.split('-');
        if (parts.length === 3){
          const dt = new Date(parts[0], parts[1]-1, parts[2], hh, mm, 0, 0);
          if (dt > now) return dt;
          return null;
        }
      }
      if (a.days && a.days.length){
        for (let offset=0; offset<14; offset++){
          const cand = new Date(now);
          cand.setDate(now.getDate() + offset);
          cand.setHours(hh, mm, 0, 0);
          if (a.days.includes(cand.getDay())){
            if (cand > now) return cand;
          }
        }
      }
      return null;
    }

    function scheduleAlert(a){
      try{
        const next = computeNextForAlert(a);
        if (!next) return;
        const delay = Math.max(0, next - new Date());
        const obj = {};
        obj.timeout = setTimeout(()=>{
          const text = `Alerta: ${a.time}${a.date?(' • '+a.date):''}`;
          if (window.Notification && Notification.permission === 'granted'){
            new Notification('Alerta De Olho no Lixo', { body: text });
          } else {
            try { if (typeof navigator !== 'undefined' && navigator.vibrate) navigator.vibrate(200); } catch(e) {}
            alert(text);
          }
          if (a.days && a.days.length){
            // schedule next weekly occurrence
            scheduleAlert(a);
          }
        }, delay);
        scheduled[a.id] = obj;
      }catch(e){}
    }

    function scheduleAllAlerts(){
      clearScheduled();
      const arr = loadAlerts();
      arr.forEach(a=> scheduleAlert(a));
    }

    // request notification permission in background
    function ensureNotificationPermission(){
      if (!('Notification' in window)) return;
      if (Notification.permission === 'default') Notification.requestPermission().then(()=>{});
    }

    // handlers
    openBtn.addEventListener('click', (ev)=>{ ev.preventDefault(); openModal(); ensureNotificationPermission(); });
    closeBtn.addEventListener('click', closeModal);
    cancelBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', closeModal);

    form.addEventListener('submit', (ev)=>{
      ev.preventDefault();
      const date = document.getElementById('alert-date').value || '';
      const time = document.getElementById('alert-time').value || '';
      const dayNodes = document.querySelectorAll('.day-checkbox');
      const days = Array.from(dayNodes).filter(n=>n.checked).map(n=>parseInt(n.value,10));
      if (!time) { status.classList.remove('hidden'); status.textContent='Preencha a hora.'; return; }
      const alertObj = { id: uid(), date: date || null, time, days };

      // montar payload para API
      const dayCodeMap = ['SU','MO','TU','WE','TH','FR','SA'];
      const bydays = (alertObj.days && alertObj.days.length) ? alertObj.days.map(d => dayCodeMap[Number(d)]).filter(Boolean) : [];
      const payload = {};
      if (bydays.length) payload.days = bydays;
      if (alertObj.date){ const p = alertObj.date.split('-'); if (p.length===3) payload.date = `${p[2]}/${p[1]}/${p[0]}`; }
      if (alertObj.time) payload.time = alertObj.time;

      const shouldCallApi = (payload.days && payload.days.length) || payload.date;
      if (shouldCallApi){
        status.classList.remove('hidden'); status.textContent='Sincronizando com Google Calendar...';
        const csrftoken = getCookie('csrftoken');
        fetch('/calendar/schedule_weekly/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': csrftoken || ''
          },
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        }).then(async res => {
          let j={}; try{ j = await res.json(); }catch(e){}
          if (res.status === 401){
            status.textContent = 'Login necessário. Redirecionando...';
            if (j.redirect) window.location.href = j.redirect;
            return;
          }
          if (res.status === 409){
            status.textContent = 'Evento recorrente já existe no calendário.';
          } else if (!res.ok){
            status.textContent = j.error || 'Erro ao criar evento no calendário.';
            return;
          } else {
            status.textContent = 'Evento criado no Google Calendar.';
          }
          // salvar localmente e agendar notificações
          const arr = loadAlerts(); arr.push(alertObj); saveAlerts(arr); renderAlertsList(); scheduleAllAlerts();
          setTimeout(()=>{ status.classList.add('hidden'); status.textContent=''; },1200);
        }).catch(err => {
          status.classList.remove('hidden'); status.textContent = 'Erro de rede ao falar com o Calendar API.';
        });
      } else {
        // sem dias nem data -> apenas salvar local
        const arr = loadAlerts(); arr.push(alertObj); saveAlerts(arr); renderAlertsList(); scheduleAllAlerts();
        status.classList.remove('hidden'); status.textContent='Alerta salvo localmente.';
        setTimeout(()=>{ status.classList.add('hidden'); status.textContent=''; },1200);
      }
    });

    // iniciar agendamentos ao carregar
    document.addEventListener('DOMContentLoaded', ()=> {
      // already scheduled in main page script, but run here too
      scheduleAllAlerts();
    });
  })();
</script>

{% endblock content %}