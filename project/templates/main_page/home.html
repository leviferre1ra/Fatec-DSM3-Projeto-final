{% extends "allauth/layouts/base.html" %}

{% block content %}

<div class="m-0 font-[Inter] font-bold grid grid-cols-1 md:grid-cols-[450px_1fr] bg-white box-border">

  <!-- Painel lateral esquerdo -->
  <aside class="bg-white flex flex-col p-[30px] overflow-y-scroll max-h-screen py-9 scrollbar shadow-[10px_0px_6px_rgba(0,0,0,0.15)] z-[2]">

    <!-- Perfil -->
    <div class="flex items-center gap-[10px] hidden md:block">
      <span class="font-medium text-black text-[1.5rem] ml-3">Olá, <strong>{{ user.first_name|default:user.username }}</strong></span>
    </div>

    <!-- Modal de seleção de bairro -->
    <div id="div-dropdown-bairros"  class="bg-white mt-10 rounded-lg max-w-md text-center">
        <select id="dropdown-bairros" class="w-full p-3 mb-10 border border-gray-300 rounded-lg text-lg focus:ring-[#7083D9] focus:border-[#7083D9]">
            <option value="" disabled selected>Escolha um bairro...</option>
            <option value="todos">Todos</option>
            <option value="Anhanguera">Anhanguera</option>
            <option value="Antartica">Antártica</option>
            <option value="Aviacao">Aviação</option>
            <option value="Boqueirao">Boqueirão</option>
            <option value="Caicara">Caiçara</option>
            <option value="Canto do Forte">Canto do Forte</option>
            <option value="Cidade da Crianca">Cidade da Criança</option>
            <option value="Esmeralda">Esmeralda</option>
            <option value="Florida">Flórida</option>
            <option value="Gloria">Glória</option>
            <option value="Guilhermina">Guilhermina</option>
            <option value="Maracana">Maracanã</option>
            <option value="Melvi">Melvi</option>
            <option value="Mirim">Mirim</option>
            <option value="Nova Mirim">Nova Mirim</option>
            <option value="Ocian">Ocian</option>
            <option value="Princesa">Princesa</option>
            <option value="Quietude">Quietude</option>
            <option value="real">Real</option>
            <option value="Ribeiropolis">Ribeirópolis</option>
            <option value="Samambaia">Samambaia</option>
            <option value="Santa Marina">Santa Marina</option>
            <option value="Sitio do Campo">Sítio do Campo</option>
            <option value="Solemar">Solemar</option>
            <option value="Tupi">Tupi</option>
            <option value="Tupiry">Tupiry</option>
            <option value="vila sonia">Vila Sônia</option>
        </select>
    </div>


    <!-- Contagem regressiva -->
    <div class="text-center mb-[18px]">
      <h2 class="m-0 text-black font-semibold text-[1.5rem]">A coleta começa em:</h2>
      <h1 id="countdown" class="text-[4rem] text-[#7083D9] font-bold m-0">00:00:00</h1>
    </div>

    <!-- Próxima coleta -->
    <div class="bg-[#7083D9] text-white rounded-[10px] p-4 text-center mb-[23px] shadow-[10px_10px_5px_rgba(0,0,0,0.15)] z-[3]">
      <p class="m-[5px_3px] text-[1.3rem] font-normal"><strong>Próxima Coleta:</strong> <span id="proxima-coleta-date">--/--/----</span></p>
      <p class="m-[5px_3px] text-[1.3rem] font-normal"><strong>Horário Previsto:</strong> <span id="horario-previsto">--:--</span></p>
    </div>

    <!-- Alerta -->
    <div class="text-center mb-[25px]">
      <h2 class="m-0 text-black font-semibold text-[1.5rem]">Perdeu o horário da coleta?</h2>
      <a href="#" id="create-alert-link" class="text-[#7083D9] no-underline font-semibold text-[1.2rem] hover:underline">Crie um alerta para lembrar</a>
    </div>

    <!-- ALERT Modal -->
    <div id="alert-overlay" class="fixed inset-0 bg-black/50 hidden z-60"></div>
    <div id="alert-modal" class="fixed inset-0 flex items-center justify-center hidden z-70 p-4">
      <div class="bg-white rounded-lg w-full max-w-md p-5 shadow-lg">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-semibold">Criar alerta</h3>
          <button id="alert-close" class="text-gray-500 hover:text-gray-800">✕</button>
        </div>

        <form id="alert-form" class="text-sm">
          <div>
            <label class="block font-medium mb-3">Data (opcional)</label>
            <input id="alert-date" type="date" class="w-full p-2 border rounded" />
          </div>
          <div>
            <label class="block font-medium mb-3 mt-5">Hora</label>
            <input id="alert-time" type="time" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="block font-medium mb-3 mt-5">Repetir a cada (minutos) — opcional</label>
            <input id="alert-repeat-min" type="number" min="0" placeholder="ex.: 60" class="w-full p-2 border rounded" />
          </div>
          <div>
            <label class="block font-medium mb-3 mt-5">Dias da semana (marque para repetir semanalmente)</label>
            <div class="grid grid-cols-4 text-xs">
              <label><input type="checkbox" value="0" class="day-checkbox" /> Dom</label>
              <label><input type="checkbox" value="1" class="day-checkbox" /> Seg</label>
              <label><input type="checkbox" value="2" class="day-checkbox" /> Ter</label>
              <label><input type="checkbox" value="3" class="day-checkbox" /> Qua</label>
              <label><input type="checkbox" value="4" class="day-checkbox" /> Qui</label>
              <label><input type="checkbox" value="5" class="day-checkbox" /> Sex</label>
              <label><input type="checkbox" value="6" class="day-checkbox" /> Sáb</label>
            </div>
          </div>

          <div class="flex justify-end items-center gap-3 mt-2 ">
            <button type="button" id="alert-cancel" class="px-3 py-2 rounded border">Cancelar</button>
            <button type="submit" id="alert-save" class="px-3 py-2 rounded bg-[#7083D9] text-white">Salvar alerta</button>
          </div>

          <p id="alert-status" class="text-sm text-center hidden"></p>
        </form>

        <hr class="my-3" />
        <div>
          <h4 class="font-semibold text-sm mb-2">Alertas salvos</h4>
          <ul id="alerts-list" class="text-sm space-y-2"></ul>
        </div>
      </div>
    </div>

    <script>
    (function(){
      const openBtn = document.getElementById('create-alert-link');
      const overlay = document.getElementById('alert-overlay');
      const modal = document.getElementById('alert-modal');
      const closeBtn = document.getElementById('alert-close');
      const cancelBtn = document.getElementById('alert-cancel');
      const form = document.getElementById('alert-form');
      const status = document.getElementById('alert-status');
      const alertsList = document.getElementById('alerts-list');

      function openModal(){ 
        // fecha menu lateral se estiver aberto e desabilita botão hambúrguer enquanto modal de alerta estiver aberto
        const menuEl = document.getElementById('menu');
        const menuOverlay = document.getElementById('menu-overlay');
        const menuBtn = document.getElementById('menu-btn');
        if (menuEl && !menuEl.classList.contains('translate-x-full')) {
          menuEl.classList.add('translate-x-full');
        }
        if (menuOverlay) {
          menuOverlay.classList.add('hidden');
          menuOverlay.classList.add('opacity-0');
        }
        if (menuBtn) {
          menuBtn.classList.add('pointer-events-none', 'opacity-50');
          menuBtn.setAttribute('aria-disabled','true');
        }

        overlay.classList.remove('hidden'); 
        modal.classList.remove('hidden'); 
        renderAlertsList(); 
      }

      function closeModal(){ 
        overlay.classList.add('hidden'); 
        modal.classList.add('hidden'); 
        status.classList.add('hidden'); 
        status.textContent=''; 
        form.reset(); 

        // reativa o botão hambúrguer
        const menuBtn = document.getElementById('menu-btn');
        if (menuBtn) {
          menuBtn.classList.remove('pointer-events-none', 'opacity-50');
          menuBtn.removeAttribute('aria-disabled');
        }
      }

      function loadAlerts(){ try { return JSON.parse(localStorage.getItem('user_alerts')||'[]'); } catch(e){ return []; } }
      function saveAlerts(arr){ localStorage.setItem('user_alerts', JSON.stringify(arr)); }

      function renderAlertsList(){
        const arr = loadAlerts();
        alertsList.innerHTML = '';
        if (!arr.length) { alertsList.innerHTML = '<li class="text-xs text-gray-500">Nenhum alerta</li>'; return; }
        arr.forEach(a=>{
          const li = document.createElement('li');
          li.className = 'flex justify-between items-center';
          const txt = document.createElement('div');
          const days = (a.days && a.days.length)? a.days.map(d=>['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'][d]).join(', '): (a.date||'único');
          txt.innerHTML = `<div class="font-medium">${a.time} ${a.date?('— '+a.date):''}</div><div class="text-xs text-gray-600">${days} ${a.repeatMin?(' • repete cada '+a.repeatMin+'m'):''}</div>`;
          const del = document.createElement('button');
          del.className = 'px-2 py-1 text-xs border rounded';
          del.textContent = 'Excluir';
          del.addEventListener('click', ()=>{
            const newArr = loadAlerts().filter(x=>x.id !== a.id);
            saveAlerts(newArr);
            renderAlertsList();
            scheduleAllAlerts(); // atualizar timers
          });
          li.appendChild(txt);
          li.appendChild(del);
          alertsList.appendChild(li);
        });
      }

      function uid(){ return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }

      // calcula próximo Date object para alerta (considera date OR days-of-week + time)
      function nextOccurrence(a){
        const now = new Date();
        const [hh,mm] = a.time.split(':').map(n=>parseInt(n,10)||0);
        if (a.date){ // specific date
          const parts = a.date.split('-'); // yyyy-mm-dd
          const dt = new Date(parts[0], parts[1]-1, parts[2], hh, mm, 0, 0);
          if (dt > now) return dt;
          return null;
        }
        if (a.days && a.days.length){
          for (let dOff=0; dOff<14; dOff++){
            const cand = new Date(now);
            cand.setDate(now.getDate() + dOff);
            if (a.days.includes(cand.getDay())){
              cand.setHours(hh,mm,0,0);
              if (cand > now) return cand;
            }
          }
        }
        return null;
      }

      // agendamento simples: dispara notificacao (Notification API se permitido) e se repeatMin set interval
      const scheduled = {}; // id -> timeouts/intervals

      function clearScheduled(){
        Object.values(scheduled).forEach(o=>{
          if (o.timeout) clearTimeout(o.timeout);
          if (o.interval) clearInterval(o.interval);
        });
        for(const k in scheduled) delete scheduled[k];
      }

      function scheduleAlert(a){
        // clear existing for this id
        if (scheduled[a.id]) { if (scheduled[a.id].timeout) clearTimeout(scheduled[a.id].timeout); if (scheduled[a.id].interval) clearInterval(scheduled[a.id].interval); }
        const next = nextOccurrence(a);
        if (!next) return;
        const delay = Math.max(0, next - new Date());
        const obj = {};
        obj.timeout = setTimeout(()=> {
          // notify
          const text = `Alerta: ${a.time}${a.date?(' • '+a.date):''}`;
          if (window.Notification && Notification.permission === 'granted'){
            new Notification('Alerta De Olho no Lixo', { body: text });
          } else {
            try { if (typeof navigator !== 'undefined' && navigator.vibrate) navigator.vibrate(200); } catch(e) {}
            alert(text);
          }
          // se repetir em minutos, criar interval
          if (a.repeatMin && Number(a.repeatMin) > 0){
            obj.interval = setInterval(()=> {
              const t = `Alerta (repetição): ${a.time}${a.date?(' • '+a.date):''}`;
              if (window.Notification && Notification.permission === 'granted') new Notification('Alerta De Olho no Lixo', { body: t });
              else alert(t);
            }, Number(a.repeatMin)*60*1000);
          } else {
            // se é para dias da semana, agendar próxima ocorrência recursiva
            if (a.days && a.days.length){
              // agendar próxima chamada (re-run schedule)
              scheduleAlert(a);
            }
          }
        }, delay);
        scheduled[a.id] = obj;
      }

      function scheduleAllAlerts(){
        clearScheduled();
        const arr = loadAlerts();
        arr.forEach(a=> scheduleAlert(a));
      }

      // request notification permission in background
      function ensureNotificationPermission(){
        if (!('Notification' in window)) return;
        if (Notification.permission === 'default') Notification.requestPermission().then(()=>{});
      }

      // handlers
      openBtn.addEventListener('click', (ev)=>{ ev.preventDefault(); openModal(); ensureNotificationPermission(); });
      closeBtn.addEventListener('click', closeModal);
      cancelBtn.addEventListener('click', closeModal);
      overlay.addEventListener('click', closeModal);

      form.addEventListener('submit', (ev)=>{
        ev.preventDefault();
        const date = document.getElementById('alert-date').value || '';
        const time = document.getElementById('alert-time').value || '';
        const repeatMin = document.getElementById('alert-repeat-min').value || '';
        const dayNodes = document.querySelectorAll('.day-checkbox');
        const days = Array.from(dayNodes).filter(n=>n.checked).map(n=>parseInt(n.value,10));
        if (!time) { status.classList.remove('hidden'); status.textContent='Preencha a hora.'; return; }
        const alertObj = { id: uid(), date: date || null, time, repeatMin: repeatMin?Number(repeatMin):0, days };
        const arr = loadAlerts();
        arr.push(alertObj);
        saveAlerts(arr);
        status.classList.remove('hidden'); status.textContent='Alerta salvo.';
        renderAlertsList();
        scheduleAllAlerts();
        setTimeout(()=>{ status.classList.add('hidden'); status.textContent=''; },1200);
      });

      // iniciar agendamentos ao carregar
      document.addEventListener('DOMContentLoaded', ()=> {
        // already scheduled in main page script, but run here too
        scheduleAllAlerts();
      });
    })();
    </script>

  <!-- Últimas coletas -->
  <div class="w-full mb-[25px] flex justify-center hidden md:block">
    <div class="bg-[#ffb84d] text-[#4e4e4e] text-[1rem] rounded-[10px] p-[14px]
      shadow-[10px_10px_5px_rgba(0,0,0,0.15)] z-[3] text-center
      mx-auto w-full">

      <h3 class="text-black m-0 mb-[8px] text-[1.1rem]">Últimas coletas</h3>

      <ul id="ultimas-coletas-list" class="list-none m-0 px-[6px] text-[#4e4e4e]">
        <!-- preenchido dinamicamente -->
      </ul>
    </div>
  </div>


      <!-- Rodapé -->
    <footer class="text-center text-[0.9rem] font-semibold text-[#4e4e4e] mt-6 hidden md:block">
      Precisa de ajuda? <a href="#ajuda" class="text-[#7083D9] no-underline hover:underline">Clique aqui</a>
    </footer>
  </aside>

  
  <!-- Mapa -->
  <main class="w-full h-full z-[1]">
    <div id="map" class="w-full h-screen"></div>
  </main>

</div>

<!-- Leaflet CSS e JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  let map;
  let geoJsonLayer;
  let bairroSelecionado = localStorage.getItem('bairroSelecionado') || '';
  let initialGeojson = null;
  let currentNextDate = null;
  let countdownInterval = null;
  // Dia atual (passado do backend)
  const diaAtual = "{{ dia_atual|escapejs }}";

  // Mapeamento português -> número do getDay() (0 = domingo)
  const diaParaNumero = {
    'domingo': 0,
    'segunda': 1,
    'terca': 2, 'terça': 2,
    'quarta': 3,
    'quinta': 4,
    'sexta': 5,
    'sabado': 6, 'sábado': 6
  };

  function parseHorario(horarioStr) {
    if (!horarioStr) return { h: 0, m: 0 };
    const parts = horarioStr.trim().split(':');
    const h = parseInt(parts[0], 10) || 0;
    const m = parseInt(parts[1], 10) || 0;
    return { h, m };
  }

  function getNextDateForFeature(feature) {
    const props = feature.properties || {};
    const dias = Array.isArray(props.Dias) ? props.Dias.map(d => d.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '')) : [];
    const horario = props['Horário'] || props['Horario'] || props.horario || '';
    const { h, m } = parseHorario(horario);

    const now = new Date();
    for (let offset = 0; offset < 14; offset++) { // checar próximas duas semanas para segurança
      const candidate = new Date(now);
      candidate.setDate(now.getDate() + offset);
      candidate.setHours(h, m, 0, 0);
      const candidateDayNum = candidate.getDay(); // 0..6
      // verificar se candidateDayNum está em dias
      const matches = dias.some(d => diaParaNumero[d] === candidateDayNum);
      if (matches) {
        // Se for hoje (offset==0), garantir que o horário ainda não passou
        if (offset === 0 && candidate <= now) {
          continue;
        }
        return candidate;
      }
    }
    return null;
  }

  function formatDateBR(date) {
    if (!date) return '--/--/----';
    const dd = String(date.getDate()).padStart(2, '0');
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const yyyy = date.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  }

  function formatTime(date) {
    if (!date) return '--:--';
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
  }

  function startCountdown(toDate) {
    currentNextDate = toDate;
    if (countdownInterval) clearInterval(countdownInterval);
    if (!toDate) {
      document.getElementById('countdown').textContent = '—';
      return;
    }
    function update() {
      const now = new Date();
      let diff = Math.max(0, Math.floor((toDate - now) / 1000)); // segundos
      const days = Math.floor(diff / 86400);
      diff %= 86400;
      const hours = Math.floor(diff / 3600);
      diff %= 3600;
      const minutes = Math.floor(diff / 60);
      const seconds = diff % 60;
      let text = '';
      if (days > 0) text += days + 'd ';
      text += String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
      document.getElementById('countdown').textContent = text;
      if (toDate - now <= 0) {
        clearInterval(countdownInterval);
        // opcional: recarregar dados do bairro para próxima ocorrência
      }
    }
    update();
    countdownInterval = setInterval(update, 1000);
  }

  // Inicializar mapa
  function inicializarMapa() {
    map = L.map('map').setView([-24.0053, -46.4124], 15);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    geoJsonLayer = L.geoJSON(null, {
      style: function(feature) {
        const props = feature.properties || {};
        const dias = Array.isArray(props.Dias) ? props.Dias : [];
        const normalized = dias.map(d => d.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, ''));
        const isActive = normalized.includes(diaAtual.toString().toLowerCase());
        return {
          color: isActive ? '#7083D9' : '#A6A6A6',
          weight: 2,
          opacity: 0.8,
          fillOpacity: 0.3,
          fillColor: isActive ? '#7083D9' : '#A6A6A6'
        };
      },
      onEachFeature: function(feature, layer) {
        const props = feature.properties || {};
        const diasArray = Array.isArray(props.Dias) ? props.Dias : [];
        const dias = diasArray.join(', ');
        const popupContent = `
          <div class="popup-content">
            <b>${props.Bairro}</b><br>
            <strong>Dias:</strong> ${dias}<br>
            <strong>Período:</strong> ${props.Período}<br>
            <strong>Horário:</strong> ${props.Horário}
          </div>
        `;
        layer.bindPopup(popupContent);
      }
    }).addTo(map);
  }

  // Centralizar no bounds das features
  function centralizarNoMapa(geojsonData) {
    if (!geojsonData || !geojsonData.features || geojsonData.features.length === 0) {
      return;
    }
    const bounds = L.geoJSON(geojsonData).getBounds();
    map.fitBounds(bounds, { padding: [50, 50] });
  }

  // Carregar GeoJSON na camada e centralizar
  function carregarGeojson(geojsonData) {
    if (geoJsonLayer) {
      geoJsonLayer.clearLayers();
      geoJsonLayer.addData(geojsonData);
    }
    centralizarNoMapa(geojsonData);
  }

  // ----------------- Últimas coletas (últimas 4 ocorrências) -----------------
  function normalizeDia(d) {
    return (d || '').toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }

  // calcula as últimas `count` datas em que a coleta ocorreu para um array de features
  function calcularUltimasColetas(features, count = 4) {
    const now = new Date();
    const ocorrencias = [];

    if (!features || features.length === 0) return [];

    // para cada feature, para cada dia em que passa, calcular a última ocorrência (e algumas anteriores)
    features.forEach(f => {
      const p = f.properties || {};
      const dias = Array.isArray(p.Dias) ? p.Dias.map(normalizeDia) : [];
      if (dias.length === 0) return;
      const horario = p['Horário'] || p['Horario'] || p.horario || '00:00';
      const parts = horario.split(':');
      const h = parseInt(parts[0], 10) || 0;
      const m = parseInt(parts[1], 10) || 0;

      dias.forEach(diaStr => {
        const norm = normalizeDia(diaStr);
        const target = diaParaNumero[norm];
        if (target === undefined) return;

        // construir datetime de hoje com a hora da coleta
        const cand = new Date(now);
        cand.setHours(h, m, 0, 0);
        const todayWD = cand.getDay();

        // delta dias entre hoje e o weekday alvo (0..6)
        let delta = (todayWD - target + 7) % 7;
        // se hoje é o dia alvo, mas horário ainda não passou -> última ocorrência foi 7 dias atrás
        if (delta === 0 && cand > now) delta = 7;

        const last = new Date(cand);
        last.setDate(cand.getDate() - delta);

        // adicionar last e mais 3 ocorrências anteriores (subtraindo semanas)
        for (let i = 0; i < 4; i++) {
          const dt = new Date(last);
          dt.setDate(last.getDate() - 7 * i);
          if (dt <= now) {
            ocorrencias.push({ date: dt, horario: `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}` });
          }
        }
      });
    });

    // ordenar desc e pegar os 4 mais recentes, removendo duplicatas
    ocorrencias.sort((a, b) => b.date - a.date);
    const unique = [];
    const seen = new Set();
    for (const o of ocorrencias) {
      const key = o.date.toISOString();
      if (!seen.has(key)) {
        unique.push(o);
        seen.add(key);
      }
      if (unique.length >= count) break;
    }
    return unique;
  }

  function atualizarUltimasColetasUI(features) {
    const ul = document.getElementById('ultimas-coletas-list');
    if (!ul) return;
    ul.innerHTML = '';
    const ultimas = calcularUltimasColetas(features, 4);
    if (!ultimas.length) {
      const li = document.createElement('li');
      li.className = 'py-[4px] font-medium border-b border-dashed border-[rgba(0,0,0,0.06)]';
      li.textContent = 'Nenhuma coleta registrada ainda';
      ul.appendChild(li);
      return;
    }
    ultimas.forEach(item => {
      const li = document.createElement('li');
      li.className = 'py-[4px] font-medium border-b border-dashed border-[rgba(0,0,0,0.06)] flex items-center justify-center gap-3';
      li.innerHTML = `<span>${formatDateBR(item.date)}</span><span class="text-sm text-[#4e4e4e]">${item.horario}</span>`;
      ul.appendChild(li);
    });
  }
  // ----------------- fim Últimas coletas -----------------

  // calcula próxima coleta entre features e atualiza UI
  function atualizarInfoDasFeatures(geojsonData) {
    if (!geojsonData || !geojsonData.features || geojsonData.features.length === 0) {
      document.getElementById('proxima-coleta-date').textContent = '--/--/----';
      document.getElementById('horario-previsto').textContent = '--:--';
      startCountdown(null);
      atualizarUltimasColetasUI([]);
      return;
    }
    // para cada feature calcula a próxima data; escolhe a mais próxima (menor)
    let next = null;
    let nextFeature = null;
    geojsonData.features.forEach(f => {
      const d = getNextDateForFeature(f);
      if (d && (!next || d < next)) {
        next = d;
        nextFeature = f;
      }
    });

    // atualizar lista de últimas coletas imediatamente
    atualizarUltimasColetasUI(geojsonData.features);

    if (next) {
      document.getElementById('proxima-coleta-date').textContent = formatDateBR(next);
      document.getElementById('horario-previsto').textContent = formatTime(next);
      startCountdown(next);
    } else {
      document.getElementById('proxima-coleta-date').textContent = 'Sem previsão';
      document.getElementById('horario-previsto').textContent = '--:--';
      startCountdown(null);
    }
  }

  // Listener para mudança no dropdown
  // Helpers para criação de alerta no Google Calendar via AJAX
  function getCookie(name) {
    const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return v ? v.pop() : '';
  }

  async function createAlertFromPage() {
    const dateText = document.getElementById('proxima-coleta-date').textContent.trim();
    const timeText = document.getElementById('horario-previsto').textContent.trim();
    if (!dateText || dateText.includes('--') || !timeText || timeText.includes('--')) {
      alert('Não há data/hora disponível para criar o alerta.');
      return;
    }
    const linkEl = document.getElementById('create-alert-link');
    const url = (linkEl && linkEl.dataset && linkEl.dataset.createUrl) ? linkEl.dataset.createUrl : '{% url 'create_event' %}';
    const csrftoken = getCookie('csrftoken');
    try {
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({date: dateText, time: timeText})
        });
        const data = await resp.json();
        if (!resp.ok) {
           if (data && data.redirect) {
             // usuário não autenticado com Google: redirecionar para login
             window.location.href = data.redirect;
             return;
           }
           alert('Erro ao criar alerta: ' + (data.error || resp.statusText));
           return;
        }
        // Sucesso
        alert('Alerta criado com sucesso no seu Google Calendar.');
        if (data.link) {
          window.open(data.link, '_blank');
        }
    } catch (err) {
        console.error(err);
        alert('Erro ao criar alerta.');
    }
  }

  document.getElementById('dropdown-bairros').addEventListener('change', function() {
    const bairro = this.value;

    if (!bairro) return;

    // Caso especial: mostrar todos os bairros (restaurar visão completa)
    if (bairro === 'todos') {
      localStorage.removeItem('bairroSelecionado');
      if (initialGeojson) {
        carregarGeojson(initialGeojson);
        atualizarInfoDasFeatures(initialGeojson);
        console.log('Mostrando todos os bairros');
      }
      return;
    }

    // Salvar bairro selecionado no localStorage
    localStorage.setItem('bairroSelecionado', bairro);

    // Fazer requisição AJAX ao endpoint que já implementaste
    fetch(`/api/carregar-bairro/?bairro=${encodeURIComponent(bairro)}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // data.geojson já é um FeatureCollection
          carregarGeojson(data.geojson);
          atualizarInfoDasFeatures(data.geojson);
          // garantir que a lista de últimas coletas também foi atualizada
          atualizarUltimasColetasUI(data.geojson.features || []);
          console.log('Bairro carregado:', bairro);
        } else {
          console.error('Erro ao carregar bairro:', data.error);
        }
      })
      .catch(error => console.error('Erro:', error));
  });

  // Inicializar na primeira carga
  document.addEventListener('DOMContentLoaded', function() {
    inicializarMapa();

    initialGeojson = {{ geojson|default:"null"|safe }};
    if (initialGeojson) {
      carregarGeojson(initialGeojson);
      atualizarInfoDasFeatures(initialGeojson);
    } else {
      atualizarUltimasColetasUI([]);
    }

    // Restaurar bairro selecionado do localStorage
    const dropdown = document.getElementById('dropdown-bairros');
    if (bairroSelecionado) {
      dropdown.value = bairroSelecionado;
      if (bairroSelecionado !== 'todos') {
        // requisitar os dados filtrados sem recarregar a página
        fetch(`/api/carregar-bairro/?bairro=${encodeURIComponent(bairroSelecionado)}`)
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              carregarGeojson(data.geojson);
              atualizarInfoDasFeatures(data.geojson);
            }
          })
          .catch(err => console.error(err));
      }
    } else {
      dropdown.value = 'todos';
    }
    // conectar listener do botão/link de criação de alerta
    const createLink = document.getElementById('create-alert-link');
    if (createLink) {
      createLink.addEventListener('click', function(e) {
        e.preventDefault();
        createAlertFromPage();
      });
    }
  });

  
</script>

{% endblock content %}